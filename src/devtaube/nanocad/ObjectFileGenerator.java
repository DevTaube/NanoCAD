package devtaube.nanocad;

import devtaube.nanocad.model.MeshComponent;
import devtaube.nanocad.model.ModelTextureComponent;
import devtaube.nanocad.model.Vertex;
import rosequartz.ecb.ECB;
import rosequartz.gfx.Texture;
import rosequartz.math.Vec3;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

public class ObjectFileGenerator {

    static class StoredVertex {

        private final int normalIndex;
        private final int texMappingIndex;
        private final int positionIndex;

        StoredVertex(Vertex vertex, Vec3 vertexNormal, List<Vec3> normals, List<int[]> uvMappings, List<Vec3> positions) {
            // try to find an already existing, same normal vector
            int foundNormalIndex = -1;
            for(int normalIndex = 0; normalIndex < normals.size(); normalIndex++) {
                if(normals.get(normalIndex).equals(vertexNormal)) {
                    foundNormalIndex = normalIndex;
                    break;
                }
            }
            // if not exists, add new
            if(foundNormalIndex == -1) {
                foundNormalIndex = normals.size();
                normals.add(vertexNormal);
            }
            // store index
            normalIndex = foundNormalIndex;
            // try to find an already existing, same texture mapping
            int foundTexMappingIndex = -1;
            for(int texMappingIndex = 0; texMappingIndex < uvMappings.size(); texMappingIndex++) {
                if(uvMappings.get(texMappingIndex)[0] == vertex.uvX && uvMappings.get(texMappingIndex)[1] == vertex.uvY) {
                    foundTexMappingIndex = texMappingIndex;
                    break;
                }
            }
            // if not exists, add new
            if(foundTexMappingIndex == -1) {
                foundTexMappingIndex = uvMappings.size();
                uvMappings.add(new int[] { vertex.uvX, vertex.uvY });
            }
            // store index
            texMappingIndex = foundTexMappingIndex;
            // try to find an already existing, same position
            int foundPositionIndex = -1;
            for(int positionIndex = 0; positionIndex < positions.size(); positionIndex++) {
                if(positions.get(positionIndex).equals(vertex.xyz)) {
                    foundPositionIndex = positionIndex;
                    break;
                }
            }
            // if not exists, add new
            if(foundPositionIndex == -1) {
                foundPositionIndex = positions.size();
                positions.add(vertex.xyz);
            }
            // store index
            positionIndex = foundPositionIndex;
        }

    }

    public String generate(String modelName) {
        DecimalFormat df = new DecimalFormat();
        df.setMaximumFractionDigits(2);
        // get current texture
        Texture[] currentTexture = new Texture[1];
        ECB.get(ModelTextureComponent.class, (modelTexture, modelTextureComponent) -> {
            currentTexture[0] = modelTextureComponent.texture;
        });
        // generate data
        ArrayList<StoredVertex[]> vertices = new ArrayList<>();
        ArrayList<String> alias = new ArrayList<>();
        ArrayList<Vec3> normals = new ArrayList<>();
        ArrayList<int[]> texMappings = new ArrayList<>();
        ArrayList<Vec3> positions = new ArrayList<>();
        ECB.get(MeshComponent.class, (mesh, meshComponent) -> {
            StoredVertex[] storedVertices = new StoredVertex[meshComponent.vertices.length];
            for(int vertexIndex = 0; vertexIndex < meshComponent.vertices.length; vertexIndex++) {
                storedVertices[vertexIndex] = new StoredVertex(
                        meshComponent.vertices[vertexIndex],
                        meshComponent.calculateSurfaceNormal(),
                        normals,
                        texMappings,
                        positions
                );
            }
            vertices.add(storedVertices);
            alias.add(meshComponent.alias);
        });
        // generate file
        StringBuilder file = new StringBuilder("# Generated by NanoCAD\n");
        file.append("o model_group\n")
                .append("mtllib ").append(modelName).append(".mtl\n")
                .append("usemtl model_texture\n")
                .append("\n");
        file.append("# surface normals\n");
        for(Vec3 normal: normals) {
            file.append("vn ")
                    .append(df.format(normal.x))
                    .append(" ")
                    .append(df.format(normal.y))
                    .append(" ")
                    .append(df.format(normal.z))
                    .append("\n");
        }
        file.append("\n");
        file.append("# texture coordinates\n");
        for(int[] texMapping: texMappings) {
            file.append("vt ")
                    .append(df.format(texMapping[0] / (float) currentTexture[0].getWidth()))
                    .append(" ")
                    .append(df.format(1 - (texMapping[1]/ (float) currentTexture[0].getHeight())))
                    .append("\n");
        }
        file.append("\n");
        file.append("# vertex positions\n");
        for(Vec3 position: positions) {
            file.append("v ")
                    .append(df.format(position.x))
                    .append(" ")
                    .append(df.format(position.y))
                    .append(" ")
                    .append(df.format(position.z))
                    .append("\n");
        }
        file.append("\n");
        file.append("# fragments\n");
        for(int meshIndex = 0; meshIndex < vertices.size(); meshIndex++) {
            StoredVertex[] mesh = vertices.get(meshIndex);
            file.append("f ");
            for(StoredVertex vertex: mesh) {
                file.append(vertex.positionIndex + 1)
                        .append("/")
                        .append(vertex.texMappingIndex + 1)
                        .append("/")
                        .append(vertex.normalIndex + 1)
                        .append(" ");
            }
            if(alias.get(meshIndex) != null) {
                file.append("# nanocad-alias=")
                        .append(alias.get(meshIndex));
            } else {
                file.deleteCharAt(file.length() - 1);
            }
            file.append("\n");
        }
        return file.toString();
    }

}
